#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

namespace NinjaTrader.NinjaScript.Strategies
{
	public class PTZDailyPlanStrategy : Strategy
	{
//		private NinjaTrader.NinjaScript.Indicators.PropTraderz.PTZDailyPlanURLv2 ptzIndicator;

		private double lastCheckPrice;
		private DateTime lastCheckTime;
		private Dictionary<double, string> priceLevels;
		private DateTime lastLevelUpdate;

		// Track levels that have been crossed for retrace entry logic
		private Dictionary<double, LevelCrossInfo> levelCrossTracker;

		// Daily P&L tracking
		private double dailyPnL;
		private DateTime currentTradingDate;
		private bool dailyLimitReached;

		// Level cooldown tracking (5-minute minimum between trades at same level)
		private Dictionary<double, DateTime> levelLastTradeTime;

		// Complex trailing stop management
		private double trailStopPrice;
		private double highestProfitReached;
		private double lowestProfitReached;

		// Enhanced error handling for stop orders
		private int stopOrderRetryCount;
		private DateTime lastStopOrderAttempt;
		private const int MAX_STOP_RETRY_ATTEMPTS = 2;
		private const int STOP_CALCULATION_DELAY_MS = 100;

		private class LevelCrossInfo
		{
			public bool CrossedAbove { get; set; }
			public bool CrossedBelow { get; set; }
			public DateTime CrossTime { get; set; }
			public string Description { get; set; }
		}

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description									= @"Trading strategy based on PTZ Daily Plan levels - buys at support/pivot bull levels, sells at resistance/pivot bear levels";
				Name										= "PTZ Daily Plan Strategy";
				Calculate									= Calculate.OnPriceChange;
				EntriesPerDirection							= 1;
				EntryHandling								= EntryHandling.AllEntries;
				IsExitOnSessionCloseStrategy				= true;
				ExitOnSessionCloseSeconds					= 30;
				IsFillLimitOnTouch							= false;
				MaximumBarsLookBack							= MaximumBarsLookBack.TwoHundredFiftySix;
				OrderFillResolution							= OrderFillResolution.Standard;
				Slippage									= 0;
				StartBehavior								= StartBehavior.WaitUntilFlat;
				TimeInForce									= TimeInForce.Gtc;
				TraceOrders									= false;
				RealtimeErrorHandling						= RealtimeErrorHandling.StopCancelClose;
				StopTargetHandling							= StopTargetHandling.PerEntryExecution;
				BarsRequiredToTrade							= 20;
				IsInstantiatedOnEachOptimizationIteration	= true;

				// Strategy Parameters
				UseSupport									= true;
				UseResistance								= true;
				UsePivotBull								= true;
				UsePivotBear								= true;
				UseStrengthConfirmed						= false;
				UseWeaknessConfirmed						= false;
				UseGLLevels									= true;

				PriceProximityTicks							= 2;
				TradeOnCrossover							= true;
				TradeOnTouch								= true;

				EnableStopLoss								= false;
				StopLossTicks								= 20;
				EnableProfitTarget							= false;
				ProfitTargetTicks							= 40;

				EnableTrailStop								= false;
				TrailStopTicks								= 30;

				// LBL Filter
				UseLBLFilter								= false;
				RequireLBLInDescription						= false;

				// Keywords (must match indicator settings)
				KeywordSupport								= "Support";
				KeywordResistance							= "Resistance";
				KeywordPivotBull							= "Pivot Bull";
				KeywordPivotBear							= "Pivot Bear";
				KeywordStrengthConfirmed					= "Strength Confirmed";
				KeywordWeaknessConfirmed					= "Weakness Confirmed";
				KeywordGL									= "GL";

				// Time Filter (EST)
				EnableTimeFilter							= true;
				TradingStartHour							= 9;
				TradingStartMinute							= 45;
				TradingEndHour								= 15;
				TradingEndMinute							= 45;

				// Daily Limits
				EnableDailyLossLimit						= true;
				DailyLossLimit								= 500;
				EnableDailyTargetLimit						= true;
				DailyTargetLimit							= 500;

				// Level Cooldown
				EnableLevelCooldown							= true;
				LevelCooldownMinutes						= 5;

				// Complex Trailing Stop (Increased defaults for NQ futures)
				EnableComplexTrailingStop					= true;
				TrailingStopInitialTicks					= 30;
				TrailingStopStep1Ticks						= 25;
				TrailingStopStep1TriggerTicks				= 20;
				TrailingStopStep2Ticks						= 20;
				TrailingStopStep2TriggerTicks				= 40;
				TrailingStopStep3Ticks						= 15;
				TrailingStopStep3TriggerTicks				= 60;

				// Enhanced stop management
				UsePercentageBasedTrailing					= false;
				PercentageTrailOffset						= 0.4;
				MinimumStopDistanceTicks					= 10;
				EnableStopCalculationDelay					= true;
			}
			else if (State == State.Configure)
			{
			}
			else if (State == State.DataLoaded)
			{
//				ptzIndicator = PTZDailyPlanURLv2();
//				AddChartIndicator(ptzIndicator);

				lastCheckPrice = 0;
				lastCheckTime = DateTime.MinValue;
				priceLevels = new Dictionary<double, string>();
				lastLevelUpdate = DateTime.MinValue;
				levelCrossTracker = new Dictionary<double, LevelCrossInfo>();

				dailyPnL = 0;
				currentTradingDate = DateTime.MinValue;
				dailyLimitReached = false;
				levelLastTradeTime = new Dictionary<double, DateTime>();

				trailStopPrice = 0;
				highestProfitReached = 0;
				lowestProfitReached = 0;
				stopOrderRetryCount = 0;
				lastStopOrderAttempt = DateTime.MinValue;
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar < BarsRequiredToTrade)
				return;

//			if (ptzIndicator == null)
//				return;

			try
			{
				// Reset daily P&L tracking on new day
				if (Time[0].Date != currentTradingDate.Date)
				{
					ResetDailyTracking();
				}

				// Update daily P&L from unrealized profit/loss
				UpdateDailyPnL();

				// Check if daily limits have been reached
				if (CheckDailyLimits())
				{
					if (!dailyLimitReached)
					{
						Print(string.Format("{0}: Daily limit reached. No new trades today. Daily P&L: {1:C}", Time[0], dailyPnL));
						dailyLimitReached = true;
					}
					return;
				}

				// Check time filter (EST)
				if (EnableTimeFilter && !IsWithinTradingHours())
				{
					return;
				}

				// Update price levels from chart drawing objects
				if (Time[0].Date != lastLevelUpdate.Date || priceLevels.Count == 0)
				{
					UpdatePriceLevelsFromChart();
					lastLevelUpdate = Time[0];
				}

				// Get current and previous price
				double currentPrice = Close[0];
				double previousPrice = lastCheckPrice > 0 ? lastCheckPrice : Close[Math.Max(0, CurrentBar - 1)];

				// Update cross tracking for all levels
				UpdateLevelCrossTracking(currentPrice, previousPrice);

				// Manage complex trailing stop for open positions
				if (EnableComplexTrailingStop && Position.MarketPosition != MarketPosition.Flat)
				{
					ManageComplexTrailingStop();
				}

				// Check for price level interactions
				CheckForBuySignals(currentPrice, previousPrice);
				CheckForSellSignals(currentPrice, previousPrice);

				// Update last check values
				lastCheckPrice = currentPrice;
				lastCheckTime = Time[0];
			}
			catch (Exception ex)
			{
				Print(string.Format("{0}: ERROR in OnBarUpdate: {1}", Time[0], ex.Message));
				Print(string.Format("Stack Trace: {0}", ex.StackTrace));
			}
		}

		private void UpdateLevelCrossTracking(double currentPrice, double previousPrice)
		{
			lock (priceLevels)
			{
				foreach (var level in priceLevels)
				{
					double levelPrice = level.Key;
					string description = level.Value;

					if (!levelCrossTracker.ContainsKey(levelPrice))
					{
						levelCrossTracker[levelPrice] = new LevelCrossInfo
						{
							CrossedAbove = false,
							CrossedBelow = false,
							CrossTime = DateTime.MinValue,
							Description = description
						};
					}

					var crossInfo = levelCrossTracker[levelPrice];

					// Check if price crossed above the level
					if (previousPrice <= levelPrice && currentPrice > levelPrice)
					{
						crossInfo.CrossedAbove = true;
						crossInfo.CrossedBelow = false;
						crossInfo.CrossTime = Time[0];
						Print(string.Format("{0}: Price crossed ABOVE {1} at {2:F2}", Time[0], description, levelPrice));
					}
					// Check if price crossed below the level
					else if (previousPrice >= levelPrice && currentPrice < levelPrice)
					{
						crossInfo.CrossedBelow = true;
						crossInfo.CrossedAbove = false;
						crossInfo.CrossTime = Time[0];
						Print(string.Format("{0}: Price crossed BELOW {1} at {2:F2}", Time[0], description, levelPrice));
					}
				}
			}
		}

		private void CheckForBuySignals(double currentPrice, double previousPrice)
		{
			// Don't enter new long if already long
			if (Position.MarketPosition == MarketPosition.Long)
				return;

			// Check for buy conditions based on level descriptions
			double buyLevelPrice = 0;
			if (ShouldBuyAtLevel(currentPrice, previousPrice, out buyLevelPrice))
			{
				try
				{
					EnterLong("Buy at Support/Pivot Bull");

					// Reset trailing stop values
					trailStopPrice = 0;
					highestProfitReached = 0;

					// Mark this level as traded
					if (EnableLevelCooldown && buyLevelPrice > 0)
					{
						levelLastTradeTime[buyLevelPrice] = Time[0];
						Print(string.Format("{0}: Level {1:F2} marked - cooldown until {2}",
							Time[0], buyLevelPrice, Time[0].AddMinutes(LevelCooldownMinutes)));
					}

					// Use standard stop/target if complex trailing is disabled
					if (!EnableComplexTrailingStop)
					{
						if (EnableStopLoss)
							SetStopLoss(CalculationMode.Ticks, StopLossTicks);

						if (EnableProfitTarget)
							SetProfitTarget(CalculationMode.Ticks, ProfitTargetTicks);

						if (EnableTrailStop)
							SetTrailStop(CalculationMode.Ticks, TrailStopTicks);
					}
				}
				catch (Exception ex)
				{
					Print(string.Format("{0}: ERROR entering long position: {1}", Time[0], ex.Message));
				}
			}
		}

		private void CheckForSellSignals(double currentPrice, double previousPrice)
		{
			// Don't enter new short if already short
			if (Position.MarketPosition == MarketPosition.Short)
				return;

			// Check for sell conditions based on level descriptions
			double sellLevelPrice = 0;
			if (ShouldSellAtLevel(currentPrice, previousPrice, out sellLevelPrice))
			{
				try
				{
					EnterShort("Sell at Resistance/Pivot Bear");

					// Reset trailing stop values
					trailStopPrice = 0;
					lowestProfitReached = 0;

					// Mark this level as traded
					if (EnableLevelCooldown && sellLevelPrice > 0)
					{
						levelLastTradeTime[sellLevelPrice] = Time[0];
						Print(string.Format("{0}: Level {1:F2} marked - cooldown until {2}",
							Time[0], sellLevelPrice, Time[0].AddMinutes(LevelCooldownMinutes)));
					}

					// Use standard stop/target if complex trailing is disabled
					if (!EnableComplexTrailingStop)
					{
						if (EnableStopLoss)
							SetStopLoss(CalculationMode.Ticks, StopLossTicks);

						if (EnableProfitTarget)
							SetProfitTarget(CalculationMode.Ticks, ProfitTargetTicks);

						if (EnableTrailStop)
							SetTrailStop(CalculationMode.Ticks, TrailStopTicks);
					}
				}
				catch (Exception ex)
				{
					Print(string.Format("{0}: ERROR entering short position: {1}", Time[0], ex.Message));
				}
			}
		}

		private void UpdatePriceLevelsFromChart()
		{
			priceLevels.Clear();

			if (ChartControl == null || ChartPanel == null)
			{
				Print(string.Format("{0}: ChartControl is null - strategy must be run on a chart", Time[0]));
				return;
			}

			try
			{
				// First, collect all Text objects to build a description lookup by price
				Dictionary<double, string> textDescriptionsByPrice = new Dictionary<double, string>();

				// First, try to get drawing objects from DrawObjects collection (indicator-drawn objects)
				if (DrawObjects != null && DrawObjects.Count > 0)
				{
					Print(string.Format("{0}: Scanning {1} objects in DrawObjects collection", Time[0], DrawObjects.Count));

					// Count object types for diagnostics
					Dictionary<string, int> objectTypeCounts = new Dictionary<string, int>();

					// First pass: collect all text descriptions
					foreach (var drawObject in DrawObjects)
					{
						if (drawObject == null)
							continue;

						// Track object types
						string typeName = drawObject.GetType().Name;
						if (!objectTypeCounts.ContainsKey(typeName))
							objectTypeCounts[typeName] = 0;
						objectTypeCounts[typeName]++;

						if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Text)
						{
							var text = drawObject as NinjaTrader.NinjaScript.DrawingTools.Text;
							double textPrice = text.Anchor.Price;
							string displayText = text.DisplayText ?? text.Tag ?? string.Empty;

							if (!string.IsNullOrEmpty(displayText))
							{
								// Round to nearest tick to match with lines
								double roundedPrice = Math.Round(textPrice / TickSize) * TickSize;
								textDescriptionsByPrice[roundedPrice] = displayText;
								Print(string.Format("  Found Text at {0:F2}: {1}", roundedPrice, displayText));
							}
						}
					}

					// Print object type summary
					Print("  DrawObject type summary:");
					foreach (var kvp in objectTypeCounts)
					{
						Print(string.Format("    {0}: {1}", kvp.Key, kvp.Value));
					}

					// NEW: Inspect ALL objects that have "HorizontalLine" in their type name
					Print(string.Format("{0}: *** INSPECTING ALL OBJECTS WITH 'HorizontalLine' IN TYPE NAME ***", Time[0]));
					int hLineCount = 0;
					int inspectCount = 0;
					foreach (var drawObject in DrawObjects)
					{
						if (drawObject != null)
						{
							string typeName = drawObject.GetType().Name;
							string fullTypeName = drawObject.GetType().FullName;

							// Check if this is a HorizontalLine
							if (typeName.Contains("HorizontalLine") || fullTypeName.Contains("HorizontalLine"))
							{
								hLineCount++;

								if (inspectCount < 10)
								{
									Print(string.Format("  Object #{0}:", inspectCount + 1));
									Print(string.Format("    Type: {0}", typeName));
									Print(string.Format("    FullType: {0}", fullTypeName));

									// Try to access common properties via reflection
									try
									{
										var objType = drawObject.GetType();

										// Try StartAnchor.Price
										var startAnchorProp = objType.GetProperty("StartAnchor");
										if (startAnchorProp != null)
										{
											var startAnchor = startAnchorProp.GetValue(drawObject);
											if (startAnchor != null)
											{
												var priceProp = startAnchor.GetType().GetProperty("Price");
												if (priceProp != null)
												{
													double price = (double)priceProp.GetValue(startAnchor);
													Print(string.Format("    Price: {0:F2}", price));
												}
											}
										}

										// Try Tag
										var tagProp = objType.GetProperty("Tag");
										if (tagProp != null)
										{
											string tag = tagProp.GetValue(drawObject)?.ToString() ?? "NO_TAG";
											Print(string.Format("    Tag: '{0}'", tag));
										}

										// Try Name
										var nameProp = objType.GetProperty("Name");
										if (nameProp != null)
										{
											string name = nameProp.GetValue(drawObject)?.ToString() ?? "";
											Print(string.Format("    Name: '{0}'", name));
										}
									}
									catch (Exception ex)
									{
										Print(string.Format("    Error accessing properties: {0}", ex.Message));
									}

									inspectCount++;
								}
							}
						}
					}
					Print(string.Format("  Total objects with 'HorizontalLine' in name: {0}", hLineCount));

					// Second pass: Extract all HorizontalLine levels with their descriptions from Tags
					Print(string.Format("{0}: *** EXTRACTING PRICE LEVELS FROM TAGS ***", Time[0]));
					int levelsExtracted = 0;
					foreach (var drawObject in DrawObjects)
					{
						if (drawObject == null)
							continue;

						string typeName = drawObject.GetType().Name;
						if (typeName == "HorizontalLine")
						{
							try
							{
								var objType = drawObject.GetType();

								// Get Price from StartAnchor
								double priceLevel = 0;
								var startAnchorProp = objType.GetProperty("StartAnchor");
								if (startAnchorProp != null)
								{
									var startAnchor = startAnchorProp.GetValue(drawObject);
									if (startAnchor != null)
									{
										var priceProp = startAnchor.GetType().GetProperty("Price");
										if (priceProp != null)
										{
											priceLevel = (double)priceProp.GetValue(startAnchor);
										}
									}
								}

								// Get Tag
								string tag = string.Empty;
								var tagProp = objType.GetProperty("Tag");
								if (tagProp != null)
								{
									tag = tagProp.GetValue(drawObject)?.ToString() ?? string.Empty;
								}

								if (priceLevel > 0 && !string.IsNullOrEmpty(tag))
								{
									// Parse the tag to extract description
									// Format: "LBL=Support: 24633|PTZDPHLine" or "GL: 25326|GOLDPTZDPHLine"
									string description = tag;

									// Remove the |PTZDPHLine or |GOLDPTZDPHLine suffix
									if (tag.Contains("|PTZDPHLine") || tag.Contains("|GOLDPTZDPHLine"))
									{
										description = tag.Split('|')[0].Trim();
									}

									// Remove the LBL= prefix
									if (description.StartsWith("LBL="))
									{
										description = description.Substring(4).Trim();
									}

									lock (priceLevels)
									{
										if (!priceLevels.ContainsKey(priceLevel))
										{
											priceLevels[priceLevel] = description;
											levelsExtracted++;

											// Print first 10 for debugging
											if (levelsExtracted <= 10)
											{
												Print(string.Format("  Level {0}: {1:F2} - {2}", levelsExtracted, priceLevel, description));
											}
										}
									}
								}
							}
							catch (Exception ex)
							{
								Print(string.Format("  Error extracting level: {0}", ex.Message));
							}
						}
					}
					Print(string.Format("  Total levels extracted: {0}", levelsExtracted));
				}

				// Also scan ChartControl.ChartObjects for manually drawn objects
				// IMPORTANT: This is where Chart Objects window shows the objects
				ChartControl.Dispatcher.InvokeAsync(() =>
				{
					try
					{
						if (ChartControl.ChartObjects != null && ChartControl.ChartObjects.Count > 0)
						{
							Print(string.Format("{0}: *** Scanning {1} objects in ChartObjects (Chart Objects Window) ***", Time[0], ChartControl.ChartObjects.Count));

							// Find the PTZDailyPlanURLv2 indicator in ChartObjects
							object ptzIndicator = null;
							foreach (var chartObject in ChartControl.ChartObjects.ToList())
							{
								if (chartObject != null && chartObject.GetType().Name == "PTZDailyPlanURLv2")
								{
									ptzIndicator = chartObject;
									Print(string.Format("  Found PTZDailyPlanURLv2 indicator in ChartObjects!"));

									// Try to access the indicator's public properties/methods using reflection
									try
									{
										var indicatorType = ptzIndicator.GetType();
										var properties = indicatorType.GetProperties();

										Print(string.Format("  PTZDailyPlanURLv2 has {0} properties:", properties.Length));

										// Look for properties that might contain collection/dictionary of levels
										foreach (var prop in properties)
										{
											string propName = prop.Name;
											var propType = prop.PropertyType;

											// Look for collections, dictionaries, or arrays that might store level data
											bool isCollection = propType.IsGenericType &&
											    (propType.GetGenericTypeDefinition() == typeof(Dictionary<,>) ||
											     propType.GetGenericTypeDefinition() == typeof(List<>) ||
											     propType.Name.Contains("Collection"));

											bool isArray = propType.IsArray;

											// Look for properties with relevant names or collection types
											if (isCollection || isArray ||
											    propName.Contains("Level") || propName.Contains("Price") ||
											    propName.Contains("Support") || propName.Contains("Resistance") ||
											    propName.Contains("Pivot") || propName.Contains("Bull") || propName.Contains("Bear") ||
											    propName.Contains("Line") || propName.Contains("Zone") || propName.Contains("Data"))
											{
												try
												{
													var value = prop.GetValue(ptzIndicator);
													string valueStr = value?.ToString() ?? "null";
													string typeStr = propType.Name;

													// If it's a collection, show count
													if (value != null)
													{
														if (value is System.Collections.ICollection collection)
														{
															valueStr = string.Format("{0} (Count: {1})", typeStr, collection.Count);
														}
														else if (value is System.Collections.IDictionary dict)
														{
															valueStr = string.Format("{0} (Count: {1})", typeStr, dict.Count);
														}
													}

													Print(string.Format("    Property '{0}' [{1}] = {2}", propName, typeStr, valueStr));
												}
												catch (Exception ex)
												{
													Print(string.Format("    Property '{0}' - Error: {1}", propName, ex.Message));
												}
											}
										}

										// Also check for common indicator value series
										var valuesProperty = indicatorType.GetProperty("Values");
										if (valuesProperty != null)
										{
											var values = valuesProperty.GetValue(ptzIndicator);
											if (values != null)
											{
												Print(string.Format("  Indicator has Values collection: {0}", values.GetType().Name));
											}
										}
									}
									catch (Exception ex)
									{
										Print(string.Format("  Error inspecting PTZDailyPlanURLv2: {0}", ex.Message));
									}
									break;
								}
							}

							if (ptzIndicator == null)
							{
								Print("  WARNING: PTZDailyPlanURLv2 indicator not found in ChartObjects");
							}

							// Count types in ChartObjects
							Dictionary<string, int> chartObjectTypeCounts = new Dictionary<string, int>();
							foreach (var drawObject in ChartControl.ChartObjects.ToList())
							{
								if (drawObject != null)
								{
									string typeName = drawObject.GetType().Name;
									if (!chartObjectTypeCounts.ContainsKey(typeName))
										chartObjectTypeCounts[typeName] = 0;
									chartObjectTypeCounts[typeName]++;
								}
							}

							Print("  ChartObject type summary:");
							foreach (var kvp in chartObjectTypeCounts)
							{
								Print(string.Format("    {0}: {1}", kvp.Key, kvp.Value));
							}

							// NEW: Inspect first 10 HorizontalLine objects to find price levels
							Print(string.Format("{0}: *** INSPECTING HORIZONTAL LINES FOR PRICE LEVELS ***", Time[0]));
							int hLineCount = 0;
							foreach (var drawObject in ChartControl.ChartObjects.ToList())
							{
								if (drawObject != null && drawObject is NinjaTrader.NinjaScript.DrawingTools.HorizontalLine)
								{
									hLineCount++;
									if (hLineCount <= 10)
									{
										var hLine = drawObject as NinjaTrader.NinjaScript.DrawingTools.HorizontalLine;
										double price = hLine.StartAnchor.Price;
										string tag = hLine.Tag ?? "NO_TAG";

										Print(string.Format("  HLine #{0}: Price={1:F2}, Tag='{2}'", hLineCount, price, tag));

										// Try to find nearby text objects within 5 ticks
										double proximityInPrice = 5 * TickSize;
										foreach (var textObj in ChartControl.ChartObjects.ToList())
										{
											if (textObj != null && textObj is NinjaTrader.NinjaScript.DrawingTools.Text)
											{
												var text = textObj as NinjaTrader.NinjaScript.DrawingTools.Text;
												double textPrice = text.Anchor.Price;

												if (Math.Abs(textPrice - price) <= proximityInPrice)
												{
													string displayText = text.DisplayText ?? text.Tag ?? "";
													Print(string.Format("    -> Found nearby text at {0:F2}: '{1}'", textPrice, displayText));
												}
											}
										}
									}
								}
							}
							Print(string.Format("  Total HorizontalLines found: {0}", hLineCount));

							// First pass: collect text descriptions from ChartObjects
							Dictionary<double, string> chartTextDescriptions = new Dictionary<double, string>();
							int chartDebugCount = 0;
							foreach (var drawObject in ChartControl.ChartObjects.ToList())
							{
								if (drawObject == null)
									continue;

								if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Text)
								{
									var text = drawObject as NinjaTrader.NinjaScript.DrawingTools.Text;
									double textPrice = text.Anchor.Price;
									string displayText = text.DisplayText ?? text.Tag ?? string.Empty;

									if (!string.IsNullOrEmpty(displayText))
									{
										double roundedPrice = Math.Round(textPrice / TickSize) * TickSize;
										chartTextDescriptions[roundedPrice] = displayText;
										Print(string.Format("  Found ChartObject Text at {0:F2}: {1}", roundedPrice, displayText));
									}
								}

								// Debug HorizontalLines from ChartObjects
								if (drawObject is NinjaTrader.NinjaScript.DrawingTools.HorizontalLine && chartDebugCount < 5)
								{
									var hLine = drawObject as NinjaTrader.NinjaScript.DrawingTools.HorizontalLine;
									try
									{
										string tag = hLine.Tag ?? "";
										string name = "";
										try { name = hLine.GetType().GetProperty("Name")?.GetValue(hLine)?.ToString() ?? ""; } catch { }

										Print(string.Format("  DEBUG ChartObject HorizontalLine #{0}:", chartDebugCount + 1));
										Print(string.Format("    Price={0:F2}", hLine.StartAnchor.Price));
										Print(string.Format("    Tag='{0}'", tag));
										Print(string.Format("    Name='{0}'", name));
									}
									catch (Exception ex)
									{
										Print(string.Format("  DEBUG ChartObject Error: {0}", ex.Message));
									}
									chartDebugCount++;
								}
							}

							// Second pass: process lines and match with text
							foreach (var drawObject in ChartControl.ChartObjects.ToList())
							{
								if (drawObject == null)
									continue;

								string tag = string.Empty;
								double priceLevel = 0;
								string description = string.Empty;

								if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Line)
								{
									var line = drawObject as NinjaTrader.NinjaScript.DrawingTools.Line;
									priceLevel = line.StartAnchor.Price;
									tag = line.Tag ?? string.Empty;
									description = tag;
								}
								else if (drawObject is NinjaTrader.NinjaScript.DrawingTools.HorizontalLine)
								{
									var hLine = drawObject as NinjaTrader.NinjaScript.DrawingTools.HorizontalLine;
									priceLevel = hLine.StartAnchor.Price;
									tag = hLine.Tag ?? string.Empty;
									description = tag;
								}
								else if (drawObject is NinjaTrader.NinjaScript.DrawingTools.Ray)
								{
									var ray = drawObject as NinjaTrader.NinjaScript.DrawingTools.Ray;
									priceLevel = ray.StartAnchor.Price;
									tag = ray.Tag ?? string.Empty;
									description = tag;
								}

								if (priceLevel > 0)
								{
									// If no description from tag, look for nearby text within 2 ticks
									if (string.IsNullOrEmpty(description))
									{
										double roundedPrice = Math.Round(priceLevel / TickSize) * TickSize;

										// Try exact match first
										if (chartTextDescriptions.ContainsKey(roundedPrice))
										{
											description = chartTextDescriptions[roundedPrice];
										}
										else
										{
											// Try within 2 ticks
											double proximityInPrice = 2 * TickSize;
											foreach (var kvp in chartTextDescriptions)
											{
												if (Math.Abs(kvp.Key - roundedPrice) <= proximityInPrice)
												{
													description = kvp.Value;
													break;
												}
											}
										}
									}

									if (!string.IsNullOrEmpty(description))
									{
										lock (priceLevels)
										{
											if (!priceLevels.ContainsKey(priceLevel))
											{
												priceLevels[priceLevel] = description;
												Print(string.Format("  Added from ChartObjects: {0:F2} - {1}", priceLevel, description));
											}
										}
									}
								}
							}
						}
					}
					catch (Exception ex)
					{
						Print(string.Format("Error in ChartObjects Dispatcher: {0}", ex.Message));
					}
				});

				// Give dispatcher time to complete
				System.Threading.Thread.Sleep(100);

				int levelCount = 0;
				lock (priceLevels)
				{
					levelCount = priceLevels.Count;
				}

				if (levelCount > 0)
				{
					Print(string.Format("{0}: Successfully loaded {1} price levels", Time[0], levelCount));

					// Print details of each level for debugging
					lock (priceLevels)
					{
						foreach (var level in priceLevels)
						{
							Print(string.Format("  Active Level: {0:F2} - {1}", level.Key, level.Value));
						}
					}
				}
				else
				{
					Print(string.Format("{0}: WARNING - No price levels found. Check:", Time[0]));
					Print("  1. Indicator is loaded on the chart");
					Print("  2. Indicator has drawn levels with text labels");
					Print("  3. Drawing objects have tags or text descriptions");
					Print(string.Format("  DrawObjects count: {0}", DrawObjects != null ? DrawObjects.Count : 0));
				}
			}
			catch (Exception ex)
			{
				Print(string.Format("Error updating price levels: {0}", ex.Message));
				Print(string.Format("Stack trace: {0}", ex.StackTrace));
			}
		}

		private void ResetDailyTracking()
		{
			currentTradingDate = Time[0].Date;
			dailyPnL = 0;
			dailyLimitReached = false;
			Print(string.Format("{0}: New trading day started. Daily limits reset.", Time[0]));
		}

		private void UpdateDailyPnL()
		{
			try
			{
				double unrealizedPnL = Position.GetUnrealizedProfitLoss(PerformanceUnit.Currency, Close[0]);
				double realizedPnL = SystemPerformance.AllTrades.TradesPerformance.Currency.CumProfit;

				// Calculate daily P&L
				dailyPnL = realizedPnL + unrealizedPnL;
			}
			catch (Exception ex)
			{
				Print(string.Format("{0}: ERROR updating daily P&L: {1}", Time[0], ex.Message));
			}
		}

		private bool CheckDailyLimits()
		{
			if (EnableDailyLossLimit && dailyPnL <= -DailyLossLimit)
			{
				return true;
			}

			if (EnableDailyTargetLimit && dailyPnL >= DailyTargetLimit)
			{
				return true;
			}

			return false;
		}

		private bool IsWithinTradingHours()
		{
			try
			{
				// Convert current time to EST
				TimeZoneInfo estZone = TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
				DateTime estTime = TimeZoneInfo.ConvertTime(Time[0], estZone);

				int currentHour = estTime.Hour;
				int currentMinute = estTime.Minute;

				// Check if before trading start
				if (currentHour < TradingStartHour ||
					(currentHour == TradingStartHour && currentMinute < TradingStartMinute))
				{
					return false;
				}

				// Check if after trading end
				if (currentHour > TradingEndHour ||
					(currentHour == TradingEndHour && currentMinute >= TradingEndMinute))
				{
					return false;
				}

				return true;
			}
			catch (Exception ex)
			{
				Print(string.Format("{0}: ERROR checking trading hours: {1}", Time[0], ex.Message));
				return true;
			}
		}

		private bool IsLevelOnCooldown(double levelPrice)
		{
			if (!EnableLevelCooldown)
				return false;

			if (levelLastTradeTime.ContainsKey(levelPrice))
			{
				DateTime lastTradeTime = levelLastTradeTime[levelPrice];
				TimeSpan timeSinceLastTrade = Time[0] - lastTradeTime;

				if (timeSinceLastTrade.TotalMinutes < LevelCooldownMinutes)
				{
					return true;
				}
			}

			return false;
		}

		private void ManageComplexTrailingStop()
		{
			try
			{
			if (Position.MarketPosition == MarketPosition.Flat)
			{
				// Reset retry counter when flat
				stopOrderRetryCount = 0;
				return;
			}

			// Add calculation delay to avoid chasing price too aggressively
			if (EnableStopCalculationDelay)
			{
				TimeSpan timeSinceLastAttempt = Time[0] - lastStopOrderAttempt;
				if (timeSinceLastAttempt.TotalMilliseconds < STOP_CALCULATION_DELAY_MS)
				{
					return; // Too soon, skip this update
				}
			}

			double currentPrice = Close[0];
			double unrealizedProfitTicks = 0;
			double newStopPrice = 0;
			double trailDistance = TrailingStopInitialTicks;

			if (Position.MarketPosition == MarketPosition.Long)
			{
				unrealizedProfitTicks = (currentPrice - Position.AveragePrice) / TickSize;

				// Track highest profit reached
				if (unrealizedProfitTicks > highestProfitReached)
				{
					highestProfitReached = unrealizedProfitTicks;
				}

				// Use percentage-based trailing if enabled
				if (UsePercentageBasedTrailing)
				{
					trailDistance = Math.Max(
						(Position.AveragePrice * PercentageTrailOffset / 100.0) / TickSize,
						MinimumStopDistanceTicks
					);
				}
				else
				{
					// Determine trail distance based on profit tiers
					if (highestProfitReached >= TrailingStopStep3TriggerTicks)
					{
						trailDistance = TrailingStopStep3Ticks;
					}
					else if (highestProfitReached >= TrailingStopStep2TriggerTicks)
					{
						trailDistance = TrailingStopStep2Ticks;
					}
					else if (highestProfitReached >= TrailingStopStep1TriggerTicks)
					{
						trailDistance = TrailingStopStep1Ticks;
					}
				}

				newStopPrice = currentPrice - (trailDistance * TickSize);

				// Validate stop price with minimum buffer below current price
				double minStopPrice = currentPrice - ((trailDistance + MinimumStopDistanceTicks) * TickSize);
				if (newStopPrice > minStopPrice)
				{
					newStopPrice = minStopPrice;
					Print(string.Format("{0}: Long stop adjusted to safe distance: {1:F2}", Time[0], newStopPrice));
				}

				// Initialize or update stop price
				if (trailStopPrice == 0 || newStopPrice > trailStopPrice)
				{
					trailStopPrice = newStopPrice;

					// Attempt to set stop with error handling
					if (TrySetStopLoss(trailStopPrice, MarketPosition.Long, currentPrice))
					{
						stopOrderRetryCount = 0;
						lastStopOrderAttempt = Time[0];
						Print(string.Format("{0}: Long Trailing Stop updated to {1:F2} (Trail: {2:F1} ticks, Profit: {3:F1} ticks)",
							Time[0], trailStopPrice, trailDistance, unrealizedProfitTicks));
					}
				}
			}
			else if (Position.MarketPosition == MarketPosition.Short)
			{
				unrealizedProfitTicks = (Position.AveragePrice - currentPrice) / TickSize;

				// Track lowest profit reached (highest for shorts)
				if (unrealizedProfitTicks > lowestProfitReached)
				{
					lowestProfitReached = unrealizedProfitTicks;
				}

				// Use percentage-based trailing if enabled
				if (UsePercentageBasedTrailing)
				{
					trailDistance = Math.Max(
						(Position.AveragePrice * PercentageTrailOffset / 100.0) / TickSize,
						MinimumStopDistanceTicks
					);
				}
				else
				{
					// Determine trail distance based on profit tiers
					if (lowestProfitReached >= TrailingStopStep3TriggerTicks)
					{
						trailDistance = TrailingStopStep3Ticks;
					}
					else if (lowestProfitReached >= TrailingStopStep2TriggerTicks)
					{
						trailDistance = TrailingStopStep2Ticks;
					}
					else if (lowestProfitReached >= TrailingStopStep1TriggerTicks)
					{
						trailDistance = TrailingStopStep1Ticks;
					}
				}

				newStopPrice = currentPrice + (trailDistance * TickSize);

				// Validate stop price with minimum buffer above current price
				double currentBid = GetCurrentBidPrice();
				double minStopPrice = currentBid + (MinimumStopDistanceTicks * TickSize);

				// CRITICAL: For short positions, buy-to-cover stop MUST be above market
				if (newStopPrice <= minStopPrice)
				{
					newStopPrice = minStopPrice;
					Print(string.Format("{0}: Short stop adjusted to safe distance above bid: {1:F2} (Bid: {2:F2}, Buffer: {3} ticks)",
						Time[0], newStopPrice, currentBid, MinimumStopDistanceTicks));
				}

				// Initialize or update stop price
				if (trailStopPrice == 0 || newStopPrice < trailStopPrice)
				{
					trailStopPrice = newStopPrice;

					// Attempt to set stop with error handling
					if (TrySetStopLoss(trailStopPrice, MarketPosition.Short, currentPrice))
					{
						stopOrderRetryCount = 0;
						lastStopOrderAttempt = Time[0];
						Print(string.Format("{0}: Short Trailing Stop updated to {1:F2} (Trail: {2:F1} ticks, Profit: {3:F1} ticks)",
							Time[0], trailStopPrice, trailDistance, unrealizedProfitTicks));
					}
				}
			}

			}
			catch (Exception ex)
			{
				Print(string.Format("{0}: ERROR managing trailing stop: {1}", Time[0], ex.Message));
				// Strategy remains enabled - error is logged but doesn't disable strategy
			}
		}

		private bool TrySetStopLoss(double stopPrice, MarketPosition position, double currentPrice)
		{
			try
			{
				double currentBid = GetCurrentBidPrice();
				double currentAsk = GetCurrentAskPrice();

				// Final validation before placing order
				if (position == MarketPosition.Short)
				{
					// Buy-to-cover stop MUST be above current bid
					if (stopPrice <= currentBid)
					{
						if (stopOrderRetryCount < MAX_STOP_RETRY_ATTEMPTS)
						{
							stopOrderRetryCount++;
							double adjustedStop = currentBid + (MinimumStopDistanceTicks * TickSize);
							Print(string.Format("{0}: Stop order validation failed - adjusting from {1:F2} to {2:F2} (Attempt {3}/{4})",
								Time[0], stopPrice, adjustedStop, stopOrderRetryCount, MAX_STOP_RETRY_ATTEMPTS));
							stopPrice = adjustedStop;
						}
						else
						{
							Print(string.Format("{0}: Stop order retry limit reached - keeping previous stop", Time[0]));
							return false;
						}
					}
				}
				else if (position == MarketPosition.Long)
				{
					// Sell stop MUST be below current ask
					if (stopPrice >= currentAsk)
					{
						if (stopOrderRetryCount < MAX_STOP_RETRY_ATTEMPTS)
						{
							stopOrderRetryCount++;
							double adjustedStop = currentAsk - (MinimumStopDistanceTicks * TickSize);
							Print(string.Format("{0}: Stop order validation failed - adjusting from {1:F2} to {2:F2} (Attempt {3}/{4})",
								Time[0], stopPrice, adjustedStop, stopOrderRetryCount, MAX_STOP_RETRY_ATTEMPTS));
							stopPrice = adjustedStop;
						}
						else
						{
							Print(string.Format("{0}: Stop order retry limit reached - keeping previous stop", Time[0]));
							return false;
						}
					}
				}

				// Place the stop order
				SetStopLoss(CalculationMode.Price, stopPrice);
				return true;
			}
			catch (Exception ex)
			{
				Print(string.Format("{0}: ERROR in TrySetStopLoss: {1} - Strategy continues running", Time[0], ex.Message));
				return false;
			}
		}

		private double GetCurrentBidPrice()
		{
			try
			{
				if (GetCurrentBid() != null)
					return GetCurrentBid().Price;
				return Close[0]; // Fallback to last close
			}
			catch
			{
				return Close[0];
			}
		}

		private double GetCurrentAskPrice()
		{
			try
			{
				if (GetCurrentAsk() != null)
					return GetCurrentAsk().Price;
				return Close[0]; // Fallback to last close
			}
			catch
			{
				return Close[0];
			}
		}

		private bool ShouldBuyAtLevel(double currentPrice, double previousPrice, out double levelPrice)
		{
			levelPrice = 0;

			lock (priceLevels)
			{
				if (priceLevels.Count == 0)
					return false;

				double proximity = PriceProximityTicks * TickSize;

				foreach (var level in priceLevels)
				{
					double currentLevelPrice = level.Key;
					string description = level.Value.ToLower();

					// Check if level is on cooldown
					if (IsLevelOnCooldown(currentLevelPrice))
					{
						continue;
					}

					// DIAGNOSTIC: Print what we're checking
					Print(string.Format("{0}: Checking BUY level {1:F2} - Description: '{2}' (UseGLLevels={3}, KeywordGL='{4}')",
						Time[0], currentLevelPrice, description, UseGLLevels, KeywordGL.ToLower()));

					// Apply LBL filter if enabled
					if (UseLBLFilter)
					{
						bool hasLBL = description.Contains("lbl");

						// If RequireLBLInDescription is true, only trade levels WITH "LBL"
						// If RequireLBLInDescription is false, only trade levels WITHOUT "LBL"
						if (RequireLBLInDescription && !hasLBL)
						{
							Print(string.Format("  -> Skipped: LBL filter (requires LBL but not found)"));
							continue;
						}
						if (!RequireLBLInDescription && hasLBL)
						{
							Print(string.Format("  -> Skipped: LBL filter (excludes LBL but found)"));
							continue;
						}
					}

					bool isBuyLevel = false;

					// Standard keyword checks
					if (UseSupport && description.Contains(KeywordSupport.ToLower()))
					{
						isBuyLevel = true;
						Print(string.Format("  -> Matched Support keyword"));
					}
					if (UsePivotBull && description.Contains(KeywordPivotBull.ToLower()))
					{
						isBuyLevel = true;
						Print(string.Format("  -> Matched Pivot Bull keyword"));
					}
					if (UseStrengthConfirmed && description.Contains(KeywordStrengthConfirmed.ToLower()))
					{
						isBuyLevel = true;
						Print(string.Format("  -> Matched Strength Confirmed keyword"));
					}

					// GL levels: if GL is BELOW current price, treat as support
					if (UseGLLevels && description.Contains(KeywordGL.ToLower()) && currentLevelPrice < currentPrice)
					{
						isBuyLevel = true;
						Print(string.Format("  -> GL level at {1:F2} is BELOW price {2:F2} - treating as SUPPORT", Time[0], currentLevelPrice, currentPrice));
					}
					else if (UseGLLevels && description.Contains(KeywordGL.ToLower()) && currentLevelPrice >= currentPrice)
					{
						Print(string.Format("  -> GL level at {1:F2} is NOT below price {2:F2} - NOT a buy level", Time[0], currentLevelPrice, currentPrice));
					}
					else if (UseGLLevels && !description.Contains(KeywordGL.ToLower()))
					{
						Print(string.Format("  -> GL enabled but description doesn't contain '{0}'", KeywordGL.ToLower()));
					}

					if (isBuyLevel)
					{
						// Check if we have cross tracking info for this level
						if (levelCrossTracker.ContainsKey(currentLevelPrice))
						{
							var crossInfo = levelCrossTracker[currentLevelPrice];

							// For BUY at support: Price crossed below the level, now retracing back above
							if (crossInfo.CrossedBelow && previousPrice < currentLevelPrice && currentPrice >= currentLevelPrice)
							{
								Print(string.Format("{0}: BUY Signal - Price retraced back above {1} at {2:F2} after crossing below", Time[0], description, currentLevelPrice));
								crossInfo.CrossedBelow = false;
								levelPrice = currentLevelPrice;
								return true;
							}
						}

						// Also allow immediate touch/crossover if configured
						if (TradeOnCrossover)
						{
							// For support: Enter on initial cross below then back above
							if (previousPrice < currentLevelPrice - proximity && currentPrice >= currentLevelPrice)
							{
								Print(string.Format("{0}: BUY Signal - Price crossed above {1} at {2:F2}", Time[0], description, currentLevelPrice));
								levelPrice = currentLevelPrice;
								return true;
							}
						}

						if (TradeOnTouch)
						{
							// Touch from below
							if (currentPrice >= currentLevelPrice - proximity && currentPrice <= currentLevelPrice + proximity)
							{
								Print(string.Format("{0}: BUY Signal - Price touching {1} at {2:F2}", Time[0], description, currentLevelPrice));
								levelPrice = currentLevelPrice;
								return true;
							}
						}
					}
					else
					{
						// Diagnostic output for levels that don't match
						if (description.Contains(KeywordGL.ToLower()))
						{
							Print(string.Format("{0}: Level {1:F2} '{2}' - Not a BUY level (GL is above price, checking: UseGLLevels={3})", Time[0], currentLevelPrice, description, UseGLLevels));
						}
					}
				}

				return false;
			}
		}

		private bool ShouldSellAtLevel(double currentPrice, double previousPrice, out double levelPrice)
		{
			levelPrice = 0;

			lock (priceLevels)
			{
				if (priceLevels.Count == 0)
					return false;

				double proximity = PriceProximityTicks * TickSize;

				foreach (var level in priceLevels)
				{
					double currentLevelPrice = level.Key;
					string description = level.Value.ToLower();

					// Check if level is on cooldown
					if (IsLevelOnCooldown(currentLevelPrice))
					{
						continue;
					}

					// DIAGNOSTIC: Print what we're checking
					Print(string.Format("{0}: Checking SELL level {1:F2} - Description: '{2}' (UseGLLevels={3}, KeywordGL='{4}')",
						Time[0], currentLevelPrice, description, UseGLLevels, KeywordGL.ToLower()));

					// Apply LBL filter if enabled
					if (UseLBLFilter)
					{
						bool hasLBL = description.Contains("lbl");

						// If RequireLBLInDescription is true, only trade levels WITH "LBL"
						// If RequireLBLInDescription is false, only trade levels WITHOUT "LBL"
						if (RequireLBLInDescription && !hasLBL)
						{
							Print(string.Format("  -> Skipped: LBL filter (requires LBL but not found)"));
							continue;
						}
						if (!RequireLBLInDescription && hasLBL)
						{
							Print(string.Format("  -> Skipped: LBL filter (excludes LBL but found)"));
							continue;
						}
					}

					bool isSellLevel = false;

					// Standard keyword checks
					if (UseResistance && description.Contains(KeywordResistance.ToLower()))
					{
						isSellLevel = true;
						Print(string.Format("  -> Matched Resistance keyword"));
					}
					if (UsePivotBear && description.Contains(KeywordPivotBear.ToLower()))
					{
						isSellLevel = true;
						Print(string.Format("  -> Matched Pivot Bear keyword"));
					}
					if (UseWeaknessConfirmed && description.Contains(KeywordWeaknessConfirmed.ToLower()))
					{
						isSellLevel = true;
						Print(string.Format("  -> Matched Weakness Confirmed keyword"));
					}

					// GL levels: if GL is ABOVE current price, treat as resistance
					if (UseGLLevels && description.Contains(KeywordGL.ToLower()) && currentLevelPrice > currentPrice)
					{
						isSellLevel = true;
						Print(string.Format("  -> GL level at {1:F2} is ABOVE price {2:F2} - treating as RESISTANCE", Time[0], currentLevelPrice, currentPrice));
					}
					else if (UseGLLevels && description.Contains(KeywordGL.ToLower()) && currentLevelPrice <= currentPrice)
					{
						Print(string.Format("  -> GL level at {1:F2} is NOT above price {2:F2} - NOT a sell level", Time[0], currentLevelPrice, currentPrice));
					}
					else if (UseGLLevels && !description.Contains(KeywordGL.ToLower()))
					{
						Print(string.Format("  -> GL enabled but description doesn't contain '{0}'", KeywordGL.ToLower()));
					}

					if (isSellLevel)
					{
						// Check if we have cross tracking info for this level
						if (levelCrossTracker.ContainsKey(currentLevelPrice))
						{
							var crossInfo = levelCrossTracker[currentLevelPrice];

							// For SELL at resistance: Price crossed above the level, now retracing back below
							if (crossInfo.CrossedAbove && previousPrice > currentLevelPrice && currentPrice <= currentLevelPrice)
							{
								Print(string.Format("{0}: SELL Signal - Price retraced back below {1} at {2:F2} after crossing above", Time[0], description, currentLevelPrice));
								crossInfo.CrossedAbove = false;
								levelPrice = currentLevelPrice;
								return true;
							}
						}

						// Also allow immediate touch/crossover if configured
						if (TradeOnCrossover)
						{
							// For resistance: Enter on initial cross above then back below
							if (previousPrice > currentLevelPrice + proximity && currentPrice <= currentLevelPrice)
							{
								Print(string.Format("{0}: SELL Signal - Price crossed below {1} at {2:F2}", Time[0], description, currentLevelPrice));
								levelPrice = currentLevelPrice;
								return true;
							}
						}

						if (TradeOnTouch)
						{
							// Touch from above
							if (currentPrice >= currentLevelPrice - proximity && currentPrice <= currentLevelPrice + proximity)
							{
								Print(string.Format("{0}: SELL Signal - Price touching {1} at {2:F2}", Time[0], description, currentLevelPrice));
								levelPrice = currentLevelPrice;
								return true;
							}
						}
					}
					else
					{
						// Diagnostic output for levels that don't match
						if (description.Contains(KeywordGL.ToLower()))
						{
							Print(string.Format("{0}: Level {1:F2} '{2}' - Not a SELL level (GL is below price, checking: UseGLLevels={3})", Time[0], currentLevelPrice, description, UseGLLevels));
						}
					}
				}

				return false;
			}
		}

		#region Properties

		[NinjaScriptProperty]
		[Display(Name="Use Support Levels", Description="Enable trading at Support levels", Order=1, GroupName="1) Level Types")]
		public bool UseSupport
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Resistance Levels", Description="Enable trading at Resistance levels", Order=2, GroupName="1) Level Types")]
		public bool UseResistance
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Pivot Bull Levels", Description="Enable trading at Pivot Bull levels", Order=3, GroupName="1) Level Types")]
		public bool UsePivotBull
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Pivot Bear Levels", Description="Enable trading at Pivot Bear levels", Order=4, GroupName="1) Level Types")]
		public bool UsePivotBear
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Strength Confirmed", Description="Enable trading at Strength Confirmed levels", Order=5, GroupName="1) Level Types")]
		public bool UseStrengthConfirmed
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Weakness Confirmed", Description="Enable trading at Weakness Confirmed levels", Order=6, GroupName="1) Level Types")]
		public bool UseWeaknessConfirmed
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use GL Levels (Dynamic)", Description="Enable trading at GL levels (above price = resistance, below price = support)", Order=7, GroupName="1) Level Types")]
		public bool UseGLLevels
		{ get; set; }

		[NinjaScriptProperty]
		[Range(0, int.MaxValue)]
		[Display(Name="Price Proximity (Ticks)", Description="How close price must be to trigger (in ticks)", Order=1, GroupName="2) Entry Rules")]
		public int PriceProximityTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Trade on Crossover", Description="Enter when price crosses the level", Order=2, GroupName="2) Entry Rules")]
		public bool TradeOnCrossover
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Trade on Touch", Description="Enter when price touches/is near the level", Order=3, GroupName="2) Entry Rules")]
		public bool TradeOnTouch
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use LBL Filter", Description="Enable filtering based on LBL keyword in descriptions", Order=4, GroupName="2) Entry Rules")]
		public bool UseLBLFilter
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Require LBL in Description", Description="If enabled: only trade levels WITH 'LBL'. If disabled: only trade levels WITHOUT 'LBL'", Order=5, GroupName="2) Entry Rules")]
		public bool RequireLBLInDescription
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Stop Loss", Description="Use stop loss orders", Order=1, GroupName="3) Risk Management")]
		public bool EnableStopLoss
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Stop Loss (Ticks)", Description="Stop loss distance in ticks", Order=2, GroupName="3) Risk Management")]
		public int StopLossTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Profit Target", Description="Use profit target orders", Order=3, GroupName="3) Risk Management")]
		public bool EnableProfitTarget
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Profit Target (Ticks)", Description="Profit target distance in ticks", Order=4, GroupName="3) Risk Management")]
		public int ProfitTargetTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Trail Stop", Description="Use trailing stop orders", Order=5, GroupName="3) Risk Management")]
		public bool EnableTrailStop
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Trail Stop (Ticks)", Description="Trailing stop distance in ticks", Order=6, GroupName="3) Risk Management")]
		public int TrailStopTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Support Keyword", Description="Keyword to identify support levels", Order=1, GroupName="4) Keywords")]
		public string KeywordSupport
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Resistance Keyword", Description="Keyword to identify resistance levels", Order=2, GroupName="4) Keywords")]
		public string KeywordResistance
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Pivot Bull Keyword", Description="Keyword to identify pivot bull levels", Order=3, GroupName="4) Keywords")]
		public string KeywordPivotBull
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Pivot Bear Keyword", Description="Keyword to identify pivot bear levels", Order=4, GroupName="4) Keywords")]
		public string KeywordPivotBear
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Strength Confirmed Keyword", Description="Keyword to identify strength confirmed levels", Order=5, GroupName="4) Keywords")]
		public string KeywordStrengthConfirmed
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Weakness Confirmed Keyword", Description="Keyword to identify weakness confirmed levels", Order=6, GroupName="4) Keywords")]
		public string KeywordWeaknessConfirmed
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="GL Keyword", Description="Keyword to identify GL (Golden Level) levels", Order=7, GroupName="4) Keywords")]
		public string KeywordGL
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Time Filter", Description="Only trade during specific hours (EST)", Order=1, GroupName="5) Time Filter")]
		public bool EnableTimeFilter
		{ get; set; }

		[NinjaScriptProperty]
		[Range(0, 23)]
		[Display(Name="Trading Start Hour", Description="Trading start hour (0-23, EST)", Order=2, GroupName="5) Time Filter")]
		public int TradingStartHour
		{ get; set; }

		[NinjaScriptProperty]
		[Range(0, 59)]
		[Display(Name="Trading Start Minute", Description="Trading start minute (0-59)", Order=3, GroupName="5) Time Filter")]
		public int TradingStartMinute
		{ get; set; }

		[NinjaScriptProperty]
		[Range(0, 23)]
		[Display(Name="Trading End Hour", Description="Trading end hour (0-23, EST)", Order=4, GroupName="5) Time Filter")]
		public int TradingEndHour
		{ get; set; }

		[NinjaScriptProperty]
		[Range(0, 59)]
		[Display(Name="Trading End Minute", Description="Trading end minute (0-59)", Order=5, GroupName="5) Time Filter")]
		public int TradingEndMinute
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Daily Loss Limit", Description="Stop trading after reaching daily loss limit", Order=1, GroupName="6) Daily Limits")]
		public bool EnableDailyLossLimit
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, double.MaxValue)]
		[Display(Name="Daily Loss Limit ($)", Description="Maximum daily loss in dollars", Order=2, GroupName="6) Daily Limits")]
		public double DailyLossLimit
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Daily Target Limit", Description="Stop trading after reaching daily profit target", Order=3, GroupName="6) Daily Limits")]
		public bool EnableDailyTargetLimit
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, double.MaxValue)]
		[Display(Name="Daily Target Limit ($)", Description="Maximum daily profit target in dollars", Order=4, GroupName="6) Daily Limits")]
		public double DailyTargetLimit
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Level Cooldown", Description="Enforce minimum time between trades at same level", Order=1, GroupName="7) Level Cooldown")]
		public bool EnableLevelCooldown
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, 1440)]
		[Display(Name="Cooldown Minutes", Description="Minimum minutes between trades at same level", Order=2, GroupName="7) Level Cooldown")]
		public int LevelCooldownMinutes
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Complex Trailing Stop", Description="Use multi-tier trailing stop system", Order=1, GroupName="8) Complex Trailing Stop")]
		public bool EnableComplexTrailingStop
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Initial Trail Distance (Ticks)", Description="Initial trailing stop distance", Order=2, GroupName="8) Complex Trailing Stop")]
		public int TrailingStopInitialTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Step 1 Trail Distance (Ticks)", Description="Trailing distance after reaching Step 1 trigger", Order=3, GroupName="8) Complex Trailing Stop")]
		public int TrailingStopStep1Ticks
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Step 1 Trigger (Ticks)", Description="Profit ticks to activate Step 1 trail", Order=4, GroupName="8) Complex Trailing Stop")]
		public int TrailingStopStep1TriggerTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Step 2 Trail Distance (Ticks)", Description="Trailing distance after reaching Step 2 trigger", Order=5, GroupName="8) Complex Trailing Stop")]
		public int TrailingStopStep2Ticks
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Step 2 Trigger (Ticks)", Description="Profit ticks to activate Step 2 trail", Order=6, GroupName="8) Complex Trailing Stop")]
		public int TrailingStopStep2TriggerTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Step 3 Trail Distance (Ticks)", Description="Trailing distance after reaching Step 3 trigger", Order=7, GroupName="8) Complex Trailing Stop")]
		public int TrailingStopStep3Ticks
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, int.MaxValue)]
		[Display(Name="Step 3 Trigger (Ticks)", Description="Profit ticks to activate Step 3 trail", Order=8, GroupName="8) Complex Trailing Stop")]
		public int TrailingStopStep3TriggerTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Use Percentage-Based Trailing", Description="Use percentage of entry price instead of fixed ticks", Order=9, GroupName="8) Complex Trailing Stop")]
		public bool UsePercentageBasedTrailing
		{ get; set; }

		[NinjaScriptProperty]
		[Range(0.1, 2.0)]
		[Display(Name="Percentage Trail Offset (%)", Description="Trail offset as percentage of entry price (e.g., 0.4 = 0.4%)", Order=10, GroupName="8) Complex Trailing Stop")]
		public double PercentageTrailOffset
		{ get; set; }

		[NinjaScriptProperty]
		[Range(1, 100)]
		[Display(Name="Minimum Stop Distance (Ticks)", Description="Minimum buffer between stop price and market price", Order=11, GroupName="8) Complex Trailing Stop")]
		public int MinimumStopDistanceTicks
		{ get; set; }

		[NinjaScriptProperty]
		[Display(Name="Enable Stop Calculation Delay", Description="Add delay between stop recalculations to prevent chasing price", Order=12, GroupName="8) Complex Trailing Stop")]
		public bool EnableStopCalculationDelay
		{ get; set; }

		#endregion
	}
}
